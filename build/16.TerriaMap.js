((self||window).webpackJsonp=(self||window).webpackJsonp||[]).push([[16],{3695:function(t,e,n){"use strict";n.r(e),n.d(e,"default",(function(){return c}));var r=n(459);const o=257;function i(t,e){for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function s(t){const e=new Uint16Array(4093),n=new Uint8Array(4093);for(let t=0;t<=257;t++)e[t]=4096,n[t]=t;let r=258,s=9,c=0;function l(){r=258,s=9}function f(t){const e=function(t,e,n){const r=e%8,i=Math.floor(e/8),s=8-r,c=e+n-8*(i+1);let l=8*(i+2)-(e+n);const f=8*(i+2)-e;if(l=Math.max(0,l),i>=t.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),o;let a=t[i]&2**(8-r)-1;a<<=n-s;let u=a;if(i+1<t.length){let e=t[i+1]>>>l;e<<=Math.max(0,n-f),u+=e}if(c>8&&i+2<t.length){const r=8*(i+3)-(e+n);u+=t[i+2]>>>r}return u}(t,c,s);return c+=s,e}function a(t,o){return n[r]=o,e[r]=t,r++,r-1}function u(t){const r=[];for(let o=t;4096!==o;o=e[o])r.push(n[o]);return r}const h=[];l();const d=new Uint8Array(t);let w,p=f(d);for(;p!==o;){if(256===p){for(l(),p=f(d);256===p;)p=f(d);if(p===o)break;if(p>256)throw new Error(`corrupted code at scanline ${p}`);i(h,u(p)),w=p}else if(p<r){const t=u(p);i(h,t),a(w,t[t.length-1]),w=p}else{const t=u(w);if(!t)throw new Error(`Bogus entry. Not in dictionary, ${w} / ${r}, position: ${c}`);i(h,t),h.push(t[t.length-1]),a(w,t[t.length-1]),w=p}r+1>=2**s&&(12===s?w=void 0:s++),p=f(d)}return new Uint8Array(h)}class c extends r.a{decodeBlock(t){return s(t).buffer}}},459:function(t,e,n){"use strict";function r(t,e){let n=t.length-e,r=0;do{for(let n=e;n>0;n--)t[r+e]+=t[r],r++;n-=e}while(n>0)}function o(t,e,n){let r=0,o=t.length;const i=o/n;for(;o>e;){for(let n=e;n>0;--n)t[r+e]+=t[r],++r;o-=e}const s=t.slice();for(let e=0;e<i;++e)for(let r=0;r<n;++r)t[n*e+r]=s[(n-r-1)*i+e]}n.d(e,"a",(function(){return i}));class i{async decode(t,e){const n=await this.decodeBlock(e),i=t.Predictor||1;if(1!==i){const e=!t.StripOffsets;return function(t,e,n,i,s,c){if(!e||1===e)return t;for(let t=0;t<s.length;++t){if(s[t]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(s[t]!==s[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const l=s[0]/8,f=2===c?1:s.length;for(let c=0;c<i&&!(c*f*n*l>=t.byteLength);++c){let i;if(2===e){switch(s[0]){case 8:i=new Uint8Array(t,c*f*n*l,f*n*l);break;case 16:i=new Uint16Array(t,c*f*n*l,f*n*l/2);break;case 32:i=new Uint32Array(t,c*f*n*l,f*n*l/4);break;default:throw new Error(`Predictor 2 not allowed with ${s[0]} bits per sample.`)}r(i,f)}else 3===e&&(i=new Uint8Array(t,c*f*n*l,f*n*l),o(i,f,l))}return t}(n,i,e?t.TileWidth:t.ImageWidth,e?t.TileLength:t.RowsPerStrip||t.ImageLength,t.BitsPerSample,t.PlanarConfiguration)}return n}}}}]);